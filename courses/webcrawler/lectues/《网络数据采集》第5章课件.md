
# 网络数据采集

# 第5章 自动跨越身份认证

- 讲师姓名：李皓
- 授课时间：2018秋季
- 共32课时，第15-18课时

## 课前引导

这一讲，我们将介绍使用网络爬虫，自动跨越身份认证的方法。


## 上节回顾

上节课主要介绍了下列内容：

- 实现Web页面内容解析的方法
- 文本内容的解析
- 类XML内容的解析
- JSON数据的解析
- OFFICE文档的解析
- 数据库文件的解析

## 本节课程主要内容

内容列表：

- 本节目标
- web身份认证技术的应用现状
- 跨越HTTP Basic认证
- 跨越HTTP Digest认证
- 跨越Oauth 认证
- 本节总结
- 课后练习

### 本节目标

本节重点讲解在爬取web页面时常常会遇到的身份认证问题。

早期web页面时代，身份认证往往通过http自带的basic、digest认证，这部分较为容易实现。

当前web认证通常使用Oauth认证，这种认证过程的复杂度较高，并且伴有二维码、验证码、滑块等，不易实现，本节重点在介绍实现Oauth认证的过程。

### web身份认证技术的应用现状

#### 知识讲解

常见的web认证技术有以下类型：

1. HTTP基本认证（HTTP Basic Auth）
2. OAuth（开放授权）
3. Cookie/Session 认证机制
4. 基于 Token 的认证机制

**HTTP基本认证（HTTP Basic Auth）**

在HTTP中，HTTP基本认证是一种允许Web浏览器或者其他客户端在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。简单而言，HTTP基本认证就是我们平时在网站中最常用的通过用户名和密码登录来认证的机制。 

- 优点： HTTP 基本认证是基本上所有流行的网页浏览器都支持。但是基本认证很少在可公开访问的互联网网站上使用，有时候会在小的私有系统中使用。 

- 缺点：HTTP 基本认证虽然足够简单，但是前提是在客户端和服务器主机之间的连接足够安全。如果没有使用SSL/TLS这样的传输层安全的协议，那么以明文传输的密钥和口令很容易被拦截。 

由于现存的浏览器保存认证信息直到标签页或浏览器关闭，或者用户清除历史记录。导致了服务器端无法主动来当前用户登出或者认证失效。

**OAuth（开放授权）**

OAuth 是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表等），而无需将用户名和密码提供给第三方应用。 OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站）在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。 

现存在OAuth 1.0和OAuth 2.0两种协议，二者互不兼容。越来越多的网络应用选择使用OAuth2.0，我们对OAuth 2.0 运行流程做简单介绍：

- 首先，客户端（Client）向资源拥有者（Resource Owner）发送授权请求（Authorization Request）
- 其次：资源拥有者授权许可（Authorization Grant）
- 第三步：客户端向验证服务器（Authorization Server）发送通过（B）获取的授权许可
- 第四步：验证服务器验证授权许可，通过的话，则返回Access Token给客户端
- 第五步：客户端通过Access Token 访问资源服务器（Resource Server）
- 最后：资源服务器返回受保护的资源（Protected Resource）

这种基于OAuth的认证机制非常适用于个人消费者类的互联网应用产品，如社交类等等。一些大的互联网公司都提供OAuth机制的API，如豆瓣、微信等等。

**认证机制是Cookie/Session 认证机制**

Cookie 是由客户端保存的小型文本文件，其内容为一系列的键值对。Cookie 是由 HTTP 服务器设置的，保存在浏览器中。Cookie会随着 HTTP请求一起发送。 Session 是存储在服务器端的，避免在客户端 Cookie 中存储敏感数据。Session 可以存储在 HTTP 服务器的内存中，也可以存在内存数据库（如redis）中。 

Cookie/Session认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效。

**基于 Token 的认证机制**

基于 Token的认证机制，有着无需长期保存用户名和密码，服务器端能主动让token失效等诸多好处，非常实用于 Web 应用和 App 已经被很多大型网站采用，比如Facebook、Github、Google+等。其流程如下： 

1. 客户端使用用户名和密码请求登录 
2. 服务端收到请求，去验证用户名与密码 
3. 验证成功后，服务器会签发一个 Token， 再把这个 Token 发送给客户端 
4. 客户端收到 Token 以后可以把它存储起来，如Cookie或者Web Storage 
5. 客户单每次向服务端请求资源的时候，都需要带着服务器端签发的 Token 
6. 服务器端收到请求，验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据；否的话，则返回对应的错误信息。

此外，在存储在客户端的 Token 存在几个问题： 

1. 存在泄露的风险。如果别人拿到你的 Token，在 Token过期之前，都可以以你的身份在别的地方登录；
2. 如果存在 Web Storage（指sessionStorage和localStorage）。由于Web Storage 可以被同源下的JavaScript直接获取到，这也就意味着网站下所有的JavaScript代码都可以获取到web Storage，这就给了XSS机会；
3. 如果存在Cookie中。虽然存在Cookie可以使用HttpOnly来防止XSS，但是使用 Cookie 却又引发了CSRF；
4. 对于泄露的风险，可以采取对Token进行对称加密，用时再解密；
5. 对于XSS而言，在处理数据时，都应该 escape and encode 所有不信任的数据；
6. 与CSRF相比，XSS更加容易防范和意识到，因此并不建议将Token存在Cookie中； 
7. 最后，网站或者应用一定要使用HTTPS。毕竟在网络层面上 Token 明文传输的话，还是非常的危险。


#### 案例与应用

![renrenlogin](images/05/renrenlogin.png)

![jdlogin](images/05/jdlogin.png)

#### 模块练习与答案

**练习**

1. 请简述HTTP协议自带的认证方式有哪几类？各有什么特点？
2. 请简述OAuth2.0的认证过程。
3. 简述基于 Token 的认证机制。

**答案**

1. 答：

 HTTP 基本认证是基本上所有流行的网页浏览器都支持。但是基本认证很少在可公开访问的互联网网站上使用，有时候会在小的私有系统中使用。
 
2. 答：

首先，客户端（Client）向资源拥有者（Resource Owner）发送授权请求（Authorization Request）
其次：资源拥有者授权许可（Authorization Grant）
第三步：客户端向验证服务器（Authorization Server）发送通过（B）获取的授权许可
第四步：验证服务器验证授权许可，通过的话，则返回Access Token给客户端
第五步：客户端通过Access Token 访问资源服务器（Resource Server）
 最后：资源服务器返回受保护的资源（Protected Resource）

3. 答：

客户端使用用户名和密码请求登录 ；服务端收到请求，去验证用户名与密码 ；验证成功后，服务器会签发一个 Token， 再把这个 Token 发送给客户端； 客户端收到 Token 以后可以把它存储起来，如Cookie或者Web Storage ；客户单每次向服务端请求资源的时候，都需要带着服务器端签发的 Token ；服务器端收到请求，验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据；否的话，则返回对应的错误信息。

#### 内容小结

本节介绍了三种主要认证方式：

- http认证
- oauth认证
- token认证

### 跨越HTTP Basic认证


#### 知识讲解

如何跨越http basic认证？

正如我们前面讲到的，HTTP基本认证是一种在用户请求服务器资源时，要求用户先提供用户名和口令等身份凭证，进行身份认证的一种简单认证方式。例如会弹出如下的用户名和密码输入对话框。

![httpbasicauth](images/05/httpbasicauth.png)

HTTP基本认证方式实现简单，但安全性不高，尤其是使用http协议传送明文密钥这一点使得这种身份认证在大型web系统中已经不多见，但仍存在于一些小型或早期建立的web系统中。

一个典型的HTTP basic认证过程如下：

![httpbasicauth](images/05/httpbasicauth2.png)

当客户端请求一个需要身份认证的页面时，如果服务器没有检查到正确的用户名和口令，服务器会响应一个401应答码，并提供一个认证域。当接到应答后，客户端显示该认证域给用户，并提示输入用户名和口令。用户输入了用户名和口令后，客户端软件会在原先的请求上增加认证消息头（值是base64encode(username+":"+password)），然后重新发送再次尝试。请求头的具体形式如下所示：

```
GET /someprivatezone/index.html HTTP/1.0
Host: localhost
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

```
服务器收到请求后会验证身份信息。如果身份信息正确则向用户返回受保护的资源。而如果用户凭据非法或无效，服务器可能再次返回401应答码，客户端可以再次提示用户输入口令。

下面我们通过具体操作来介绍如何使用python爬虫，自动跨越http basic认证方式。


#### 案例与应用

下面我们通过实例来看具体操作过程。



我们将对测试网站 https://www.httpbin.org/basic-auth/wang123/12345678 （使用前，需要到 http://httpbi.org/ 设置）使用HTTP Basic认证方式进行认证。

![httpbasicauth](images/05/httpbasicauth3.png)

这个过程的实现，可以借助 requests 模块完成。

在编写爬虫前，我们可以先使用浏览器尝试访问，大致结果如下：

![httpbasicauth](images/05/httpbasicauth4.png)

在理解下列程序后，可以先将最后一行语句中的密码'12345678'改为任意其它值，例如"1234"，此时执行代码会得到如下结果：
```
401 Client Error: UNAUTHORIZED for url: https://www.httpbin.org/basic-auth/wang123/12345678
```
然后，我们再将密码改为'12345678'，执行后会有如下结果：
```
{\n  "authenticated": true, \n  "user": "wang123"\n}\n'
```
这个结果表示认证成功了。


```python
import requests


def getHtmlwithHttpBasicAuth(url,username,password):
    """一个跨越HTTP Basic认证的示例
    注意：使用前，需要到http://httpbin.org设置auth为basic的页面，并设置用户名为：'wang123'；密码为'12345678'
    
    """
    try:
        headers = {'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9',
                   'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',
                  }

        s = requests.Session()
        r = s.get(url,headers = headers,auth=requests.auth.HTTPBasicAuth(username, password))
        r.raise_for_status()
        print(r.headers)
        return r.text
    except Exception as e:
        print(e)
    

url = 'https://www.httpbin.org/basic-auth/wang123/12345678'
getHtmlwithHttpBasicAuth(url,'wang123','12345678')
```

    {'Access-Control-Allow-Credentials': 'true', 'Access-Control-Allow-Origin': '*', 'Content-Encoding': 'gzip', 'Content-Type': 'application/json', 'Date': 'Thu, 18 Jul 2019 11:20:45 GMT', 'Referrer-Policy': 'no-referrer-when-downgrade', 'Server': 'nginx', 'X-Content-Type-Options': 'nosniff', 'X-Frame-Options': 'DENY', 'X-XSS-Protection': '1; mode=block', 'Content-Length': '66', 'Connection': 'keep-alive'}
    




    '{\n  "authenticated": true, \n  "user": "wang123"\n}\n'



### 跨越HTTP Digest认证


#### 知识讲解

接下来，我们来看如何跨越HTTP 摘要认证。HTTP摘要认证作为一种区别于 HTTP简单认证的协议，试图修复基本认证协议的严重缺陷。具体来说，摘要认证进行了如下改下：

- 一是它不以明文方式在网络上发送密码。
- 二是它可以防止恶意用户捕获并重放认证的握手过程。
- 三是可以有选择地防止对报文内容的篡改。

HTTP摘要认证的工作原理如下所示：

![HTTP摘要认证](images/05/httpdigestauth1.png)

- 首先，由客户端对某个受保护的资源发起请求。

- 接着，服务器会拒绝对未通过身份认证的客户端提供服务，返回一个401错误。同时服务器向客户端发起质询，询问用户名和摘要形式的密码，并在WWW-Authenticate字段说明认证方式是Digest，其他信息还有realm域信息、nonce随机字符串、opaque透传字段（客户端会原样返回）等。

- 当客户端收到服务器的质询后，它将弹出对话框要求用户输入用户名和密码。与基本认证不同在于，摘要认证不会在网络上发送原始密码，它传递给服务器的身份认证信息是对nonce随机数、用户密码、以及其它信息经过一系列摘要运算（md5）得到的。

- 在服务端收到请求后，由于其知道用户的原始密码及其他字段信息，使用同样的算法进行摘要计算后，两相比较即可验证用户的合法性。服务器端通过更新每次交互过程中的nonoce字段的值，可以防止恶意用户劫持和重放攻击。

以上就是HTTP 摘要认证的基本过程。我们使用爬虫程序跨越HTTP 摘要认证时也要遵循这些步骤。下面我们结合具体操作进行讲解。


#### 案例与应用

下面我们通过实例来看具体操作过程。

我们将对测试网站 https://www.httpbin.org/digest-auth/auth/wang456/1234567890 （使用前，需要到 http://httpbi.org/ 设置）使用HTTP digest 认证方式进行认证。

![HTTP digest 认证](images/05/httpdigestauth2.png)

![HTTP digest 认证](images/05/httpdigestauth3.png)


```python
在理解下列程序后，可以先将最后一行语句中的密码'12345678'改为任意其它值，例如"1234"，此时执行代码会得到如下结果：
```
401 Client Error: UNAUTHORIZED for url: https://www.httpbin.org/digest-auth/auth/wang456/1234567890
```
然后，我们再将密码改为'12345678'，执行后会有如下结果：
```
{\n  "authenticated": true, \n  "user": "wang456"\n}\n'
```
这个结果表示认证成功了。
```


```python
import requests

def getHtmlwithHttpDigestAuth(url,username,password):
    """一个跨越HTTP Basic认证的示例
    注意：使用前，需要到http://httpbin.org设置auth为basic的页面，并设置用户名为：'wang123'；密码为'12345678'
    
    """
    try:
        headers = {'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9',
                   'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36',
                  }

        s = requests.Session()
        r = s.get(url,headers = headers,auth=requests.auth.HTTPDigestAuth(username, password))
        r.raise_for_status()
        print(r.headers)
        return r.text
    except Exception as e:
        print(e)
    

url = 'https://www.httpbin.org/digest-auth/auth/wang456/1234567890'
getHtmlwithHttpDigestAuth(url,'wang456','1234567890')

```

    {'Access-Control-Allow-Credentials': 'true', 'Access-Control-Allow-Origin': '*', 'Content-Encoding': 'gzip', 'Content-Type': 'application/json', 'Date': 'Thu, 18 Jul 2019 11:38:30 GMT', 'Referrer-Policy': 'no-referrer-when-downgrade', 'Server': 'nginx', 'Set-Cookie': 'fake=fake_value; Path=/, stale_after=never; Path=/', 'X-Content-Type-Options': 'nosniff', 'X-Frame-Options': 'DENY', 'X-XSS-Protection': '1; mode=block', 'Content-Length': '66', 'Connection': 'keep-alive'}
    




    '{\n  "authenticated": true, \n  "user": "wang456"\n}\n'



#### 模块练习与答案

见习题集。

#### 内容小结

本节介绍了HTTP 摘要认证的基本过程、使用requests库跨越http 摘要认证的基本方法。

### 跨越Oauth 认证


#### 知识讲解

了解了如何使用爬虫程序跨越http 摘要认证，下面我们来讲解OAuth认证原理与使用爬虫跨越OAuth认证的方法。

Oauth它是一个开放标准，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容，OAuth2.0取代了原有的Oauth1.0,Oauth1已经处于废止状态。

OAuth它以一种简单而又标准的方法提供认证安全，可以用于web、移动应用、桌面应用。

OAuth认证中的角色有三类：用户、授权或资源服务器、客户端。

- 其中，用户是指资源所有者，比如某个微信或qq账号的所有者；
- 授权或资源服务器指保存着受保护的用户账号信息的服务器，同时它还担负着授权服务器的作用，用于验证用户身份然后为客户端派发资源访问令牌。
- 客户端是指希望获取用户身份信息、访问受限资源的第三方应用程序或网站。在访问实现之前，它必须先经过用户者授权，并且获得的授权凭证将进一步由授权服务器进行验证。

基于这3个角色，OAuth的认证和授权过程，可分为三个阶段：

- 第一阶段是：客户端（即某网站）和 资源服务器之间的协商；
- 第二阶段是：用户和 资源服务器 之间的协商；
- 第三阶段是：网站和资源服务器存储的用户数据之间的协商。

下面结合用户使用qq账号身份登录“慕课网”为例来介绍上述3个阶段。

![qq账号登录过程分析](images/05/qq账号登录过程分析.jpg)

阶段一：用户使用浏览器访问“慕课网”，此处的“慕课网”就是Oauth中的客户端。当用户选择使用QQ账号进行登录时，客户端即慕课网会向资源/授权服务器，即腾讯QQ的Oauth服务器发出认证请求，即客户端与资源/授权服务器之间进行协商。

阶段二：授权或资源服务器会显示一个要求用户输入用户名与密码的界面，用户输入正确的信息并提交后，腾讯qq的OAUTH授权或资源服务器会将认证授权信息，通过http重定向发送给客户端（慕课网），这时通常会传递给客户端某个令牌申请code，以及令牌信息。

阶段三：客户端会向资源服务器发送令牌信息用于验证并请求用户个人身份信息。如果获取成功，会切换用户视图到慕课网首页或用户信息页，表示用户已成功通过身份认证。

了解上述Oauth的认证过程，有助于我们设计出能够跨越它的网络爬虫程序。下面我们通过具体操作和实例进一步了解具体实现过程。


#### 案例与应用




Web应用程序流程 以下步骤概述了如何使用默认授权授权类型流来获取访问令牌并获取受保护资源。在此示例中，提供程序是Google，受保护资源是用户的配置文件。

1.手动从OAuth提供商处获取凭据。至少你需要一个client_id但很可能也需要一个client_secret。在此过程中，您可能还需要注册应用程序使用的默认重定向URI。将这些内容保存在Python脚本中：

https://api.weibo.com/oauth2/authorize?forcelogin=false&state=FiTKYisPzOpmCtS8N0yPIibIuI07A00J&redirect_uri=http://www.xuetangx.com/complete/weibo/&response_type=code&client_id=2021069109

=2021069109




```python
import requests
#client_id = '13391566939'
client_secret = 'asdfghjkl12345'
redirect_uri = 'http://www.xuetangx.com/complete/weibo/'
response_type='code'
client_id='2021069109'
```

2.通过重定向进行用户授权。首先，我们将从提供商提供的基本URL和先前获得的凭证创建授权URL。此外，大多数提供商会要求您要求访问某个范围。在此示例中，我们将要求Google访问用户的电子邮件地址和用户个人资料。


```python
# Note that these are Google specific scopes
scope = ['weibo.com',
             'https://www.googleapis.com/auth/userinfo.profile']
oauth = OAuth2Session(client_id, redirect_uri=redirect_uri,
                          scope=scope)
authorization_url, state = oauth.authorization_url(
        'https://accounts.google.com/o/oauth2/auth',
        # access_type and prompt are Google specific extra
        # parameters.
        access_type="offline", prompt="select_account")

print('Please go to %s and authorize access.' % authorization_url)
authorization_response = raw_input('Enter the full callback URL')
```

3.使用在用户授权期间获取的授权代码从提供程序获取访问令牌。


```python
token = oauth.fetch_token(
        'https://accounts.google.com/o/oauth2/token',
        authorization_response=authorization_response,
        # Google specific extra parameter used for client
        # authentication
        client_secret=client_secret)
```


```python
4. 使用刚刚获得的访问令牌访问受保护的资源。例如，获取用户个人资料信息。
```


```python
r = oauth.get('https://www.googleapis.com/oauth2/v1/userinfo')
```

#### 模块练习与答案

见习题集

#### 内容小结

本节介绍了以下内容：

- Oauth的基本概念、三种角色、三个阶段
- Oauth的基本认证过程；
- 使用python认证的过程。

## 本节总结


在本讲我们介绍了3种web系统中使用的身份认证方法：
- http basic认证
- http 摘要认证
- Oauth认证

通过具体操作详细介绍了如何设计网络爬虫程序，自动跨越这些认证，希望大家能够把握基本原理，开展实践，将这部分知识掌握好。谢谢大家。

## 课后练习

见习题集。
