# 分析恶意Windows程序

非恶意程序总体上由编译器良好生成；恶意程序通常结构很差，并趋向于执行预期之外的动作。

## Windows API

Windows API是一个广泛的功能集合，管理着恶意代码与微软程序库之间的交互方式。

它使用特定的术语、名字、约定，需要我们熟悉。

### 类型和匈牙利表达法

多数Windows API使用它自己的名字，来表示C语言类型。举例说明：

- DWORD，表示32位无符号整数；
- WORD，表示16位无符号整数；

Windows总体上使用匈牙利表达法，作为API函数标识符。这个表达式使用一个前缀命名模式，来使识别一个变量的类型更为容易。包含一个32位无符号整数的变量，或DWDRD，会以dw开头。举例来说，如果VirtualAllocEx函数的第三个参数是dwSize，你就知道它是一个DWORD类型。

匈牙利表达法使识别变量类型和解析代码更容易，但它也能变得笨重。

![widows api](images/windowsmalwareanalyse/windowsapi.png)

### 句柄

句柄是在操作系统中被打开或被创建的项，比如一个窗口、进程、模块、菜单、文件，等等。

句柄在它们引用一个对象或其他某个内存位置这点上很像指针。然而，和指针不同的是，句柄不能被用来进行数学操作，并且它们不总是表示对象地址。你能对句柄做的唯一的事情，就是保存它，并在后续函数调用中使用它来引用同一个对象。

### 文件系统函数

恶意代码与系统交互的一个最常用的方式就是创建或修改文件，而且独特文件名或修改为既有的文件名是明显的基于主机的感染迹象。

文件活动可以提示这个恶意代码在做什么。例如，若恶意代码创建一个文件，并在那个文件中保存Web浏览习惯，这个程序可能就是某种形式的间谍软件。

微软提供了多个函数来访问文件系统：

- CreateFile

这个函数被用来创建和打开文件。它可以打开已经存在的文件，管道，流，以及I/O设备，还能创建新的文件。参数dwCreationDisposition控制CreateFile函数是否创建一个新的文件，或是打开一个己经存在的文件。

- Readfile
- WriteFile

上面两个函数被用来对文件进行读和写。两个都将文件作为流来操作。当你第一次调用ReadFile时，你从一个文件中读取后续一些字节;下次你调用它，你读取它后面的一些字节。例如，若你打开一个文件，并用40字节大小调用ReadFile，下次你再调用它，它将会从前40个字节之后处开始读。如
你所能想象的，这两个函数都不能在一个文件中灵活地跳转。

- CreateFileMapping
- MapViewOfFile

文件映射经常被恶意代码作者使用，因为它们允许将一个文件加载到内存中，以便更加容易地进行操作。

CreateFileMapping函数负责从磁盘上加载一个文件到内存中。

MapViewOfFile函数则返回一个指向映射的基地址指针，它可以被用来访问内存中的文件。

程序调用两个函数，能够使用从MapViewOfFile函数返回的指针，在文件中的任意位置进行读取和写入。

这个特性在解析一个文件格式时极其顺手，因为你可以简单地跳转到不同内存地址。

注意:文件映射被普遍用来复制Windows加载器的功能。在获得一个文件的映射以后，恶意代码可以解析PE头，并对内存中的文件进行所有需要的修改，因此使PE文件就像被操作系
统加载器加载一样执行起来。

### 特殊文件

Windows系统中有一些特殊的文件类型，它们的访问方式与普通文件不太一样，但是它们不能通过它们的盘符与文件夹(比如c:\dots)进行访问。恶意程序经常使用特殊文件。

有些特殊文件要比普通文件更隐蔽，因为它们在列目录时不会显示出来。某些特殊文件可以提供对系统硬件和内部数据更强的访问能力。

特殊文件可以作为字符串参数被传递给任何文件操作函数中，并像普通文件一样进行操作。在这里，我们来介绍一下共享文件、可通过名字空间访问的文件和备用数据流。

#### 共享文件

共享文件是以```\\serverNamel\share或\\?\serverName\share```开头命名的特殊文件。它们用来访问保存在共享目录中的目录或文件。```\\ ? \```前缀告诉操作系统禁用所有的字符串解析，并允许访问长文件名。

#### 通过名字空间访问的文件
    
在操作系统中，还有一些文件可以通过名字空间进行访问。名字空间可以被认为是固定数目的文件夹，每一个文件夹中保存不同类型的对象。底层的名字空间是NT名字空间，以前缀\开始。

NT名字空间可以访问所有设备，以及所有在NT名字空间中存在的其他名字空间。


注意:要浏览你系统上的NT名字空间，可以使用从微软那里免费获得的WinObj对象管理器名字空间查看器。

以前缀```\\.\```开始的Win32设备名字空间，经常被恶意代码用来直接访问物理设备，并且像一个文件一样进行读写操作。

例如，一个程序可能使用```\\.\PhysicalDisk1```来直接访问PhysicalDisk1，而忽略它的文件系统，因此这允许程序通过普通API不可能做到的方式来修改磁盘。使用这个方法，恶意代码可以读写数据到一个未分配的扇区，而无须创建或访问文件，这允许它避开防病毒与安全程序的检测。

例如，几年前的Witty蠕虫通过NT命名空间访问```\Device\PhysicalDiskl```，使受害者的文件系统崩溃。它可以打开```\Device\PhysicalDiskl```，并间歇性地写数据到驱动器上的随机空间中，最终使受害者的操
作系统崩溃并无法引导。这个蠕虫持续时间不长，因为受害者的系统在这个蠕虫能够传播之前就经常发生故障了，但它对被它感染的系统造成了不小的损失。

另一个例子是恶意代码使用```\Device\PhysicalMemory```来直接访问物理内存，这允许用户空间程序写到内核空间中。这个技术己经被恶意代码用来修改内核，并隐藏用户空间的程序。

注意:从Windows 2003 SP1开始，```\Device\PhysicalMemory```从用户空间已经无法访问。然而，你仍然可以从内核空间访问到 ```\Device\PhysicalMemory```，这可以被用来访问诸如BIOS代码和配置的底层信息。


#### 备用数据流
    
备用数据流(ADS)特性允许附加数据被添加到一个己存在的NTFS文件中，相当于添加一个文件到另外一文件中。

额外数据在列一个目录时不会被显示出来，并且当显示文件内容时也不显示; 而只有在你访问流时，它才是可见的。

ADS数据流根据约定```normalFile.txt: Stream: $DATA```来命名，这允许一个程序去读写一个流。恶意代码作者喜欢ADS，因为它能被用来隐藏数据。

## Windows 注册表

Windows注册表被用来保存操作系统与程序的配置信息，比如设置和选项。

与文件系统一样，它是基于主机的感染迹象的很好来源，并且能够揭示出关于恶意代码功能的有用信息。

Windows早期用.ini文件存放配置信息。注册表被引入后，几乎所有的Windows配置信息都被保存到注册表中，包括网络驱动、启动项、用户账户、以及其它信息。

恶意代码经常使用注册表来完成持久驻留或者存储配置数据。

注册表十分庞大，以至于恶意代码有多种方法使自己驻留。

### 注册表术语

- 根键，注册表一般被划分为5个顶层节。有时，HKEY和储槽也是指根键。每个根键都有自定含义。
- 子健，根键下的子“文件夹”
- 键，一个键是注册表中的文件夹。它可以包含额外的文件夹或键值。根键、子健也是键。
- 值项，即一个配对的名字和值。
- 值或数据，值或数据是存储在注册表项中的数据。

### 根键

注册表里有5个根键：

- HKEY_LOCAL_MACHINE（HKLM)，保存对本地机器的全局设置。
- HKEY_CURRENT_USER(HKCU)，保存当前用户特定的设置。
- HKEY_CLASSES_ROOT，保存定义的类型信息。
- HKEY_CURRENT_CONFIG，保存关于当前硬件配置的设置，特别是与当前和标准配置之间不同的部分。
- HKEY_USERS，定义默认用户、新用户和当前用户的配置。

最常用的是HKLM和HKCU。

一些键实际是虚拟键值，提供一种引用底层注册表信息的方式。例如，HKEY_CURRENT_USER键实际上存储在HKEY_USERS\SID中，这里SID是当前登录用户的安全描述符。

例如，一个常用的子键，HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run，包含一系列值，这些值列举了当一个用户登录时被自动启动的可执行程序。根键是HKEY_LOCAL_MACHINE，它保存了SOFTWARE、Microsoft、Windows、CurrentVersion以及Run子键。

### Regedit

这个工具可以编辑注册表。

### 自启动程序

向Run子键中写入想，是一个设置程序自启动的方法。虽然不是一个隐蔽技术，但也被恶意程序常用。

Autoruns工具可以列举OS 启动时自动运行的代码。它会查找注册表中的25~30个位置，来找到被设计为自动运行的代码。

![autoruns](images/windowsmalwareanalyse/autoruns.png)

### 常用注册表函数

恶意代码经常使用作为Windows API一部分的注册表函数，来修改注册表，以使它们自身能够在系统引导时自动启动运行。

下面是最常用的注册表函数：

- RegOpenKeyEx，打开一个注册表进行编辑和查询。
- RegSetValueEx，添加一个新值到注册表，并设置它的数值。
- RegGetValue，返回注册表中一个值项的数值。

当在恶意代码中看到这些函数时，你应该标识出他们访问的注册表键值。


![修改注册表设置的示例代码](images/windowsmalwareanalyse/修改注册表设置的示例代码.png)

上面程序的注释信息提供了关于这些被压栈参数值的有意义信息。

- samDesired值只是了安全访问请求的类型；
- ulOptions域是一个表示这个调用选项的无符号长整数，
- hKey则是被访问根键的句柄。

这段代码在（1）处调用了RegOpenKeyEx函数，而它的参数需要打开一个到注册表键HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run的句柄。在（5）处的名字和在（4）处的数据，被作为这个函数的参数保存在栈上。在（2）处对lstrlenW的调用是需要的，可以获取到数据的大小，它在（3）处作为对RegSetValueEx函数的一个参数来提供。


### 使用.reg文件的注册表脚本

用.reg作为扩展的文件包含一个人类可读的注册表数据。当一个用户双击一个.reg文件时，他会自动通过合并文件包含的信息到注册表中，来修改注册表——几乎像一个修改注册表的脚本一样。

![reg文件样例](images/windowsmalwareanalyse/reg文件样例.png)

## 网络API

恶意代码经常要使用网络，Windows API中就有许多可以进行网络通信的函数。

创建网络特征的任务是复杂的，以后专题讨论。

现在，我们主要关注识别和理解常见的网络函数，这样可辨别出一个恶意程序在使用函数时做些什么。

### 伯克利兼容套接字

在Windows的网络选项中，恶意代码最普遍使用的是伯克利兼容套接字，它们的功能在Windows和Unix上是一样的。

这个网络功能有Winsock库实现，主要在ws2_32.dll中。

在所有库内函数中，下列几个最为常用：

- socket
- connect
- bind
- listen
- accept
- send
- recv

![伯克利兼容套接字函数](images/windowsmalwareanalyse/伯克利兼容套接字函数.png)

### 网络的服务器和客户端

网络程序通常会有服务器端和客户端。

服务器端维护一个打开套接字（socket）并等待客户端接入；

客户端，它连接到一个正在等待的套接字。

恶意代码可以是其中任意一个。

在连接一个远程套接字的客户端应用例子中，你会看到socket调用，然后紧跟着一个connect调用，之后，很可能是一个send或recv调用。

对于一个监听入站连接的服务应用，顺序则是socket、bind、listen和accept函数陆续被调用，如果需要的话，跟着是send和recv调用。这个模式是在任何网络程序中都很常见的。

注意：这个例子中没有考虑所有的错误处理和参数设置。一个实际例子中应该有不少WSAGetLastError的调用，和其他错误处理函数。

![一个有服务器套接字的简化程序样例](images/windowsmalwareanalyse/一个有服务器套接字的简化程序样例.png)


首先，WSAStartup函数初始化Win32 sockets系统，然后一个套接字通过socket函数被创建。bind函数将这个套接字附加到一个端口，listen调用将这个套接字设置为监听状态，然后accept调用挂起，等待一个来自远程套接字的连接。

### WinINet API

除了Winsock API以外，还有一个成为WinINet API的更高一级的Win API。WinINet API函数被保存在Wininet.dll中。如果一个程序从这个dll中导入函数，他就是在使用更高一级的网络API。

WinINet实现了应用层协议，如HTTP和FTP。可以根据恶意代码打开的是何种连接，来理解它在做什么事情。

- InternetOpen被用来初始化一个到互联网的连接。
- InternetOpenUrl被用来访问一个URL（它可以是一个HTTP页面或一个FTP资源）
- InternetReadFile和ReadFile类似，允许程序从一个来自互联网的下载文件中读取数据。

## 跟踪恶意代码的运行

除了使用IDA Pro中可见的跳转和指令调用之外，恶意代码还有很多方式可用来转移执行。弄清如何调用其它代码运行，是分析恶意代码很重要的。

最常见的，访问单一文件以外的代码的方法是使用DLL程序。

### DLL

动态链接库是使用库来在多个应用程序之间共享代码的Windows特有方式。一个DLL程序是不能独自运行的可执行文件，但它可以导出一些被其它应用程序使用的函数。

静态库是在DLL程序引入之前的标准方案，并且仍然在使用，但很少见。现在Windows中主要使用DLL，主要优势是被DLL程序使用的内存可以在正运行的进程之间共享。

例如，若一个库被两个不同的运行进程使用，静态库的代码会占用两倍于动态库的内存。

此外，Windows系统上已知的DLL程序，不需要在发布一个可执行文件时重新发布。这可以使代码最小化。

DLL程序也是一种有用的代码复用方式。

#### 恶意代码如何使用DLL

常见的有三种方式：

- 使用DLL保存恶意代码

有时，恶意代码作者发现将恶意代码保存到一个DLL文件比.exe文件更加有利。有些恶意代码会附加到其他进程，但是每一个进程只能包含一个.exe文件。因此恶意代码有时使用DLL程序，来将它
自己加载到另外一个进程中。

- 调用使用Windows DLL中的函数
  
几乎所有的恶意代码都使用在每个系统上都可以发现的Windows基础DLL程序。Windows DLL程序包含了需要与操作系统交互的功能。而一个恶意程序使用Windows DLL的方式，经常为恶意代
码分析师提供巨大的洞察力。之前学到的导入函数，以及本章中覆盖的函数，全部都是从Windows DLL程序导入的。

- 调用使用第三方 DLL中的函数

恶意代码也可以使用第三方DLL来和其他程序交互。当你看见从一个第三方DLL导入函数的恶意代码时，你可以推断它正在和那个程序交互，来完成它的目标。例如，它可能使用Mozilla Firefox DLL来连接到一个服务器，而不是直接通过Windows API进行连接。恶意代码也可能和一个自定义DLL程序一起发布，它使用这个DLL程序中一个还未在受害者机器上安装库的功能，例如，使用作为DLL程序发布的加密功能。


#### 基本DLL 结构


基本上，DLL文件看起来几乎和.exe文件一模一样。

DLL使用PE文件格式，并且只有一个单一标志，指示这个文件是一个DLL，而不是一个.exe。DLL经常有更多导出函数，并且通常导入函数较少。除了那个标志之外，一个DLL和一个.exe之间没有实质的区别。

DLL的主函数是DLLMain，它没有标记，而且并不是一个DLL中的导出函数，但是它在PE头中被指定为文件的入口点。任何时候一个进程加载或卸载库，会创建一个新线程，或一个已存在的线程结束时，这个函数都会被调用来通知DLL。这个通知允许DLL来管理每个进程或每个线程的资源。

多数DLL没有线程粒度的资源，并且它们忽略由线程活动引起对DllMain的调用。然而，如果DLL有必须在线程粒度进行管理的资源，那么这些资源可以为分析师提供一些提示，来了解这个DLL的目的。

### 进程

恶意代码也可以通过创建一个新进程，或修改一个己存在的进程，来执行当前程序之外的代码。一个进程是Windows正在执行的程序。每一个进程管理它自己的资源，诸如打开的句柄与内存。一个进程包含一个或多个由CPU执行的线程。传统上，恶意代码包括它自己的独立进程，但更新型的恶意代码则普遍将自身代码作为其他进程的一部分执行。

Windows使用进程作为管理资源的容器，并保持程序隔离且不相互干扰。一个Windows系统上任意时间通常有至少20-30个进程在运行，它们共享相同的系统资源，包括CPU、文件系统、内存以及硬件。如果每一个程序都需要和所有其他程序管理共享资源，那么写程序将十分困难。操作系统允许所有进程访问这些资源，而不会相互干扰。进程也通过防止一个程序的错误或崩溃影响其他程序，来为稳定性做出贡献。

操作系统中在多个进程间共享的一个尤其重要的资源是系统内存。为了达到这个目的，每一个进程被给予一块与所有其他进程隔离的内存空间，而这是进程可以使用的内存地址范围。

当进程需要内存时，操作系统会分配内存，并为这个进程提供一个地址来访问这块内存。进程可以共享内存地址，这经常发生。例如，若一个进程在内存地址0x00400000位置保存了一些东西，另一个进程也可以在那个地址保存一些东西，但是这些进程不会冲突。这些地址是相同的，但是保存数据的物理内存却是不同的。

像寄信地址一样，内存地址只在上下文环境中才有意义。就像主大街202号并不会告诉你一个具体位置，除非你同时还拥有邮政编码，地址Ox0040A010也没有告诉你数据保存在哪，除非你知道是哪个进程。一个访问内存地址Ox0040A010的恶意程序，只会影响包含恶意代码那个进程在这个位置上保存的东西;系统中其他使用这个地址的程序则不会受到影响。

#### 创建一个新进程

恶意代码最常使用的创建新进程函数是CreateProcess。这个函数有许多参数，并且调用者有很多控制它如何被创建的方法。

例如，恶意代码能够调用这个函数，来创建一个进程去执行它的恶意代码，这样便可以绕过基于主机的防火墙以及其他安全机制。或者它可以创建一个Internet Explorer的实例，然后使用那个程序来访问恶意内容。

恶意代码通常使用CreateProcess，来创建一个简单的远程shell。CreateProcess函数的一个参数，STARTUPINFO结构，包含一个进程的标准输入、标准输出以及标准错误流的句柄。一个恶意程序可以设置这些值为套接字，这样当这个程序写入标准输出时，它实际上会写到套接字上，因而允许一个攻击者执行远程shell，而不需要运行除CreateProcess之外的任何函数。

下图代码显示了CreateProcess如何用来创建一个简单的远程shell。在这段代码之前，代码已经打开了一个到远程位置的套接字。这个套接字的句柄被保存在栈上，并且输入到STARTUPINFO结构体中。然后调用了CreateProcess函数，所有这个进程的的输入输出都被路由到这个套接字上。

![使用CreateProcess调用的代码样本](images/windowsmalwareanalyse/使用CreateProcess调用的代码样本.png)

![使用CreateProcess调用的代码样本1](images/windowsmalwareanalyse/使用CreateProcess调用的代码样本1.png)


在代码的第一行，栈变量socketHandle被放到EAX寄存器中。( socket句柄在这个函数外面被初始化。)这个进程的 lpStartupInfo 结构体保存标准输出（2）、标准输入（1），以及标准错误（3），它们会被新进程使用。

套接字被放到lpStartupInfo结构体中所有这3个值里(1，2，3)。在（4）处对
dword 403098 的访问包含这个程序要执行的命令行，它最终被压到栈上作为参数（5）。在（6）处对CreateProcess的调用有10个参数，但除了lpCommandLine、1pProcessInformation以及lpStartupInfo之外的所有参数不是0就是1。(有些代表NULL值，其他代表标志，但是这些对恶
意代码分析都没有意义。)

对CreateProcess的调用会创建一个新进程，以便所有输入和输出被重定向到一个套接字。要找到这台远程主机，我们需要判断这个套接字在哪里被初始化(没有包含在上面代码中)。要发现哪个程序将被运行，我们需要通过在IDA Pro中导航到dword_ 403098地址，来找到保存在这个位置的字符串。

恶意代码经常在一个程序的资源节存储另一个程序，并创建一个新进程。恶意代码有时会在资源节中保存另外一个可执行文件。当程序运行时，它会从PE头中提取附加的可执行文件，将它写到磁盘上，然后调用CreateProcess来运行这个程序。这也可以通过DLL程序和其他可执行文件完成。当这种情况发生时，你必须打开Resource Hacker工具集中的程序，并将这个嵌入的可执行文件保存到磁盘上，然后再分析它。

### 线程

进程是执行代码的容器，线程才是Windows操作系统真正要执行的内容。线程是被CPU执行的独立指令序列，而不需要等待其它线程。一个进程包含一个或多个线程，它们执行进程中的一个部分代码。一个进程中的所有线程共享同样的内存空间，但是每一个有他自己的处理器、寄存器和栈。

#### 线程上下文

当一个线程运行时，它对CPU或CPU核有着完全控制，其它线程不能影响CPU或核的状态。一个操作系统在线程间切换之前，在CPU中的所有值会被保存到一个称为线程上下文的结构体中。然后操作系统加载这个线程上下文到一个新的线程中，并使这个新线程在CPU中执行。

下列代码显示了访问一个局部变量并将它压到栈上的例子：
```
004010DE lea edx, [esp+58h]
...
004010E2 push edx
```

上述代码中第一行，访问了一个局部变量（esp+58h），并且在EDX中保存它，然后将EDX压到堆栈上。现在，如果另一个线程正好要在这两条指令间运行一些代码，并且要修改EDX，则EDX的值就是错误的，而且代码不会正确执行。

当线程上下文切换被使用时，如果另一个线程在这两条指令之间运行，EDX的值会被保存到线程上下文中。当这个线程再次开始并执行push指令时，线程上下文就会被恢复，EDX将再次保存正确的值。通过这种方式，没有线程能够干扰其它线程的寄存器或标志。

#### 创建一个线程

CreateThread函数被用来创建一个新线程。函数的调用者指定一个起始地址，他经常被叫做start函数。