# 汇编与二进制漏洞 第2讲 cpu结构介绍

## 进制

逆向分析常用的进制有：
- 二进制
- 八进制
- 十进制
- 十六禁止

## CPU架构

- 寄存器组
- 高频时钟
- 控制单元
- 数据逻辑单元

## 指令周期

1. CPU从指令队列（内存）取出第一条指令；
2. CPU对指令的二进制位模式进行译码。
3. 若有操作数，则从内存中取出操作数
4. 执行指令，更新寄存器；
5. 将结果存放到内存中。

简单说：取值-译码-执行。

## 加载执行过程

在程序执行之前，需要用一种工具程序将其加载到内存，这种工具程序成为程序加载器。加载后，操作系统必须将CPU指向程序的入口，即程序开始执行的地址。具体步骤为：

1. 操作系统在当前磁盘目录下搜索程序的文件名。如果找不到，则在预定目录列表下搜索文件名；当OS无法检索到文件名时，它会发出一个报错信息。
2. 如果程序文件被找到，OS就访问磁盘目录中的程序文件基本信息，包括文件大小，及其在磁盘驱动器上的物理位置。
3. OS确定内存中下一个可使用的位置，将程序文件加载到内存。为该程序分配内存块，并将程序大小和位置信息加入表中（有时候成为描述符表descriptor table）。另外，OS可能调整程序内指针的值，使得他们包括程序数据地址。
4. OS 开始执行程序的第一条机器指令（入口）。当程序开始执行后，就成为了一个进程。OS为这个进程分配一个标识号，用于执行期间对其进行追踪。
5. 进程自动运行。OS的工作就是追踪进程的执行，并相应系统资源的请求。这些资源包括内存、磁盘文件和输入输出设备等。
6. 进程结束，就会从内存中移除。

## x86处理器

### 3种模式

#### 保护模式（Protected Mode）。

这是最常见的模式，这是一个受保护的并且支持多任务的环境。之所以受保护是因为在这个模式下，能够对内存及一些外围设备提供硬件级别的保护设置，如分段机制，分页机制。大部分OS都运行在这个模式下。

#### 实地址模式（Read-address mode）。

这个运行模式是为了兼容8086处理器，通常处理器上电后会处于这个模式，在实地址模式中，寻址空间只有1MB，CS、DS等称作Segment register，即段的基地址直接是Segment register的值向左移4位。在保护模式下，CS、DS等称作Segment selector，用于从GDT（Global Descriptor Table）或LDT（Local Descriptor Table）表中选择一个段描述符，基地址在段描述符内，两种情况下用法不一样，所以两者的寻址空间也差别很大。

#### 系统管理模式（System management mode ，SMM）。

这个模式提供一个跟平台相关的管理环境，比如电源管理，RAS（Reliability, Avaliability and Serviceability）功能配置或者系统安全等相关问题。这个模式下的code通常是由UEFI/BIOS提供的，对OS来说是透明的。SMM有自己独立的地址空间，OS是看不到的。处理器接收到SMI pin上的中断信号或者APIC接收到SMI中断信号的时候才会进入到SMM模式。

### Intel 64结构新模式

这个架构添加了IA-32e模式，并且IA-32e模式中又有两种子模式：

#### 兼容模式（Compatibility mode）。

兼容模式顾名思义，就是向前兼容IA-32的模式，该模式允许传统的16-bit和32-bit的程序不需要重新编译就可以跑在64-bit的 OS下。

#### 64位模式（64-bit mode）。

这个模式让应用程序能够访问64位的地址，并且该模式扩展了通用寄存器的宽度和数量。

为了简单起见，Intel 64的兼容模式和64位模式也可以叫做IA-32的兼容模式和64位模式。


## x86寄存器组

### 通用寄存器
- EAX
"累加器"(accumulator), 它是很多加法乘法指令的缺省寄存器 ；存放函数返回值。
- ECX:
- 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器.
- EDX
总是被用来放整数除法产生的余数
- EBX
基地址寄存器
- EBP
"基址指针"(BASE POINTER), 它最经常被用作高级语言函数调用的"框架指针",EBP 构成了函数的一个框架，在C++反汇编中 ebp-通常是局部变量、传进来的参数
- ESP
堆栈指针，指向当前的栈顶
- ESI/EDI
分别叫做"源/目标索引寄存器"(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.

### 标志寄存器


